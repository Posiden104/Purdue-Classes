<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>The Old Elementary Level</title><meta name="generator" content="DocBook XSL Stylesheets V1.69.1"><link rel="start" href="index.html" title="DrJava User Documentation"><link rel="up" href="ch08.html" title="Chapter 8. Language Level Facility"><link rel="prev" href="ch08s03.html" title="What Did the Old Levels Provide?"><link rel="next" href="ch08s05.html" title="The Old Intermediate Level"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">The Old Elementary Level</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch08s03.html">Prev</a> </td><th width="60%" align="center">Chapter 8. Language Level Facility</th><td width="20%" align="right"> <a accesskey="n" href="ch08s05.html">Next</a></td></tr></table><hr></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="elementaryLL"></a>The Old Elementary Level</h2></div></div></div><p> The old Elementary Level provides support for programming in functional Java, which can be taught with only algebraic data types--types that are inductively defined, such as <span class="emphasis"><em>integers</em></span>, <span class="emphasis"><em>booleans</em></span>, <span class="emphasis"><em>lists</em></span>, and <span class="emphasis"><em>trees</em></span>. Because of this, only a small subset of the Java language is necessary.  Most importantly, all fields and variables are immutable; in other words, they are automatically made final, so their values cannot  be changed once they are set. </p><p> Because of this immutability of data, <span class="emphasis"><em>for</em></span>, <span class="emphasis"><em>while</em></span>, and <span class="emphasis"><em>do</em></span> loops cannot be used at the Elementary level.  We also do not allow arrays because they are commonly used with a procedural-style approach to programming (loops) rather than an object-oriented one and are inherently mutable.  And since void return methods have few uses without mutable data, they are only allowed in JUnit test cases at this level.  We also simplify the language for the student by not allowing <span class="emphasis"><em>null</em></span> as a keyword.  This protects beginning students from getting null-pointer exceptions but also means that instructors should not  allow the students to use library functions that return null.  In addition, interfaces are not allowed at the Elementary Level; only classes and abstract classes are allowed.  By waiting to introduce interfaces until after the students are familiar with abstract classes, we hope students will have an easier time differentiating between interfaces and abstract classes. We also disallow the use of explicit access modifiers (<span class="emphasis"><em>final,</em></span> <span class="emphasis"><em>private,</em></span> <span class="emphasis"><em>static,</em></span> etc.), and instead automatically make all fields and local variables private and all methods public.  The one exception to this is that classes and methods can be denoted as <span class="emphasis"><em>abstract</em></span>.  We also do not allow the use of <span class="emphasis"><em>package</em></span> or <span class="emphasis"><em>import</em></span> statements in order to simplify the concepts that beginning students must learn.  Of course, students' classes can still reference other files in the same directory, and they also have access to all classes in the <span class="emphasis"><em>java.lang</em></span> package, and if students extend "TestCase" we automatically import <span class="emphasis"><em> junit.framework.TestCase </em></span>for them. </p><p> We automatically generate a <span class="emphasis"><em>constructor</em></span> for each class that students write at the Elementary Level.  Each class's constructor takes a value for each of its fields, and sets the fields to those values. None of a class's fields can be set outside of the automatically generated constructor. We consider fields to be any field in the class or one of its superclasses that also has a visible accessor (a method of the same name as the field that returns its type). We automatically generate <span class="emphasis"><em>accessors</em></span> for each field (for example, field my_field would have an accessor my_field()).  We also generate a <span class="emphasis"><em>toString()</em></span> method that returns a description of the object--its class name and field values, an <span class="emphasis"><em>equals()</em></span> method that determines if two objects are equal by comparing their class types and the values for each of their fields, and a <span class="emphasis"><em>hashCode()</em></span> method that follows the Java Language Specification that if two objects are equal, their hash codes are the same.  Students cannot override any augmented methods at this level. </p><p> Although at first glance this level seems limited, even the basic functionality provided is powerful and flexible.  The <span class="emphasis"><em>Composite,</em></span> <span class="emphasis"><em>Union,</em></span> <span class="emphasis"><em>Interpreter,</em></span> and <span class="emphasis"><em>Factory</em></span> patterns can all be taught at the Elementary level. </p></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch08s03.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch08.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch08s05.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">What Did the Old Levels Provide? </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> The Old Intermediate Level</td></tr></table></div></body></html>
